<section id="descricao-geral"> <h2>Descrição Geral do Projeto</h2><div align="center"> <img src="https://www.rocketboards.org/foswiki/pub/Documentation/TerasicDE1SoCDevelopmentAndEducationBoard/igp_3e6715c483b2d44cc78aca35b032c4ef_DE1-SoC_top_s.jpg"><br> <strong>Placa DE1-SoC utilizada no projeto</strong><br><br> </div><p>Este projeto consiste no desenvolvimento de um sistema completo de processamento de imagens em tempo real, implementado na placa DE1-SoC da Terasic. O sistema evoluiu através de três etapas principais, integrando progressivamente hardware programável (FPGA) com software de controle (HPS - Hard Processor System) para criar uma solução robusta de redimensionamento de imagens com interface interativa.</p><p>A primeira etapa focou na implementação de um coprocessador gráfico em Verilog capaz de realizar operações de zoom-in e zoom-out através de algoritmos especializados. A segunda etapa introduziu uma API em Assembly ARM para comunicação programável entre o HPS e a FPGA, substituindo o controle manual por chaves físicas. A terceira e última etapa implementou um sistema interativo completo com controle via mouse USB, overlay de hardware para cursor e seleção, e operações dinâmicas de corte e zoom.</p><p>O sistema final permite que usuários selecionem regiões específicas de uma imagem, apliquem algoritmos de redimensionamento em tempo real, e visualizem os resultados instantaneamente através da saída VGA, tudo controlado de forma intuitiva através de movimentos e cliques do mouse.</p> </section><section id="etapa-1"> <h2>Etapa 1: Coprocessador Gráfico em Verilog</h2><h3>Arquitetura e Componentes</h3> <p>O sistema segue o princípio de <strong>separação de funções</strong>, com uma hierarquia de controle clara e um <em>datapath</em> dedicado para operações de imagem. O módulo de topo <code>control_unity</code> integra todos os componentes, enquanto a <code>ULA</code> atua como uma unidade de controle especializada, gerenciando o fluxo de dados entre as memórias e os aceleradores de hardware.</p><div align="center"> <img src="diagramas/arquiteturgeral.png"><br> <strong>Diagrama da Arquitetura Geral do Sistema</strong><br><br> </div><h4>Componentes Principais:</h4> <ul> <li><strong>ULA</strong>: FSM hierárquica que gerencia o fluxo do sistema baseado nas entradas do usuário</li> <li><strong>Framebuffer (RAM Dual-Port)</strong>: Permite processamento e exibição de vídeo independentes</li> <li><strong>Memória ROM</strong>: Armazena a imagem original de 160x120 pixels em escala de cinza</li> <li><strong>Memória RAM</strong>: Armazena as imagens alteradas, sendo sobreescrita conforme o algoritmo selecionado</li> <li><strong>Módulos dos Algoritmos</strong>: Circuitos dedicados para cada técnica de processamento</li> </ul><h3>DataPath e Fluxo de Execução</h3> <p>O fluxo de execução segue uma sequência bem definida:</p> <ol> <li>No estado <code>ST_RESET</code>, a Unidade de Controle lê a seleção do usuário e configura o Datapath</li> <li>A FSM transita pelos estados operacionais, lendo pixels da ROM, enviando-os ao acelerador de hardware e escrevendo os resultados no Framebuffer</li> <li>O driver VGA lê continuamente o Framebuffer pela porta de leitura, exibindo pixels a 25 MHz</li> </ol><h3>Algoritmos de Redimensionamento</h3> <p>O sistema implementa quatro algoritmos principais para redimensionamento:</p><h4>Replicação de Pixel (Zoom-In)</h4> <p>Cada pixel é replicado fator×fator vezes, aumentando as dimensões da imagem sem interpolação.</p> <div align="center"> <img src="diagramas/replicacao_pixels_animada.gif"><br> <strong>Funcionamento de Replicação de Pixel - Fator 2 em uma matriz 2×2</strong><br><br> </div> <p>No módulo <code>rep_pixel</code>, o cálculo do endereço é feito como:</p> <pre><code>ram_wraddr = (linha * fator + di) * NEW_LARG + (coluna * fator + dj)</code></pre><h4>Vizinho Mais Próximo (Zoom-In)</h4> <p>Cada novo pixel da imagem ampliada recebe o valor do pixel mais próximo da imagem original.</p> <div align="center"> <img src="diagramas/vizinho_mais_proximo_matriz_compacto.gif"><br> <strong>Funcionamento de Vizinho Mais Próximo - Fator 2 em uma matriz 2×2</strong><br><br> </div> <p>Implementado no módulo <code>zoom_nn</code>, utiliza a mesma lógica de endereçamento da replicação.</p><h4>Decimação (Zoom-Out)</h4> <p>Reduz a imagem descartando pixels de forma sistemática, mantendo apenas pixels espaçados pelo fator especificado.</p> <div align="center"> <img src="diagramas/decimacao_animada.gif"><br> <strong>Funcionamento de Decimação - Fator 2 em uma matriz 4×4</strong><br><br> </div> <p>O cálculo do endereço é:</p> <pre><code>addr_ram_vga = (y_in / fator) * NEW_LARG + (x_in / fator)</code></pre><h4>Média de Blocos (Zoom-Out)</h4> <p>Divide a imagem em blocos fator×fator e calcula a média dos valores, substituindo cada bloco por um único pixel.</p> <div align="center"> <img src="diagramas/media_blocos.gif"><br> <strong>Funcionamento de Média de Blocos - Fator 2 em uma matriz 4×4</strong><br><br> </div> <p>Utiliza o mesmo cálculo de endereço da decimação, mas com processamento adicional de média.</p><h3>Módulo VGA e Exibição</h3> <p>O <code>vga_driver</code> é responsável por exibir o framebuffer no padrão VGA analógico, gerando quadros de 640×480 pixels a 60 Hz usando clock de 25 MHz. Implementa temporização precisa com contadores horizontais (0-799) e verticais (0-524), incluindo sincronismo HSYNC e VSYNC.</p><p>Para exibir a imagem processada (normalmente 160×120) na tela de 640×480, o driver realiza escala 4×, centralização automática e leitura contínua do framebuffer via porta dual-port da RAM.</p><h3>Resultados da Etapa 1</h3> <p>O projeto alcançou com êxito todos os pré-requisitos do problema, permitindo zoom-in e zoom-out com quatro algoritmos diferentes em fatores 2× e 4×. A arquitetura seguiu o modelo desejado, facilitando futuras integrações com demais componentes.</p><div align="center"> <img src="diagramas/produto.gif"><br> <strong>Sessão de testes aplicando todos os 4 algoritmos em ambos os fatores</strong><br><br> </div><p>Como erro principal, foi observada uma linha lateral em algumas imagens, principalmente na imagem original (160×120). A suspeita é que exista um erro no cálculo dos parâmetros next_x e next_y.</p> </section><section id="etapa-2"> <h2>Etapa 2: Integração da API em Assembly com o Coprocessador</h2><h3>Arquitetura e Comunicação HPS-FPGA</h3> <p>Nesta etapa, o controle do coprocessador passou a ser feito programaticamente através de uma API escrita em Assembly ARMv7, executando no Hard Processor System (HPS) da DE1-SoC. A comunicação entre HPS e FPGA é realizada via ponte AXI Lightweight (AXI-LW), mapeando periféricos da FPGA no espaço de memória do HPS.</p><div align="center"> <img src="diagramas/Captura de tela 2025-11-06 192558.png"><br> <strong>Diagrama introdutório do caminho tomado pelo programa após a API</strong><br><br> </div><p>O HPS é responsável por:</p> <ul> <li>Carregar a imagem .mif para uma RAM</li> <li>Mapear o barramento AXI-LW, obtendo o endereço virtual dos periféricos da FPGA</li> <li>Transferir os dados da imagem para a região de memória compartilhada</li> <li>Enviar instruções de controle para o coprocessador</li> <li>Aguardar o término do processamento e liberar recursos</li> </ul><div align="center"> <img src="diagramas/diagrama2.png"><br> <strong>Fluxo de operação da integração HPS-FPGA</strong><br><br> </div><h3>Fluxo de Execução da Etapa 2</h3> <ol> <li><strong>Mapeamento da Ponte (<code>mapearPonte</code>)</strong>: Cria acesso virtual à área de memória da FPGA via ponte AXI Lightweight</li> <li><strong>Leitura da Imagem (<code>carregarImagemMIF</code>)</strong>: Lê arquivo .mif e converte valores hexadecimais em bytes de 8 bits</li> <li><strong>Transferência para a FPGA (<code>transferirImagemFPGA</code>)</strong>: Copia buffer para região de memória da FPGA mapeada via PIO</li> <li><strong>Envio do Comando (<code>enviarComando</code>)</strong>: Escreve no registrador <code>CONTROL_PIO</code> o código da operação desejada</li> <li><strong>Execução na FPGA</strong>: Coprocessador lê dados e aplica algoritmo correspondente</li> <li><strong>Finalização</strong>: Liberação de recursos e desmapeamento de memória</li> </ol><h3>Estrutura de Memória e Códigos de Operação</h3> <p>O HPS acessa diretamente periféricos da FPGA através do mapeamento do dispositivo <code>/dev/mem</code>. A tabela abaixo mostra os principais registradores:</p><table> <thead> <tr> <th>Ponte / Registrador</th> <th>Função Principal</th> </tr> </thead> <tbody> <tr> <td><code>LW_virtual</code></td> <td>Endereço virtual resultante do <code>mmap()</code> sobre a região da Lightweight Bridge</td> </tr> <tr> <td><code>CONTROL_PIO_ptr</code></td> <td>Registrador usado para envio de códigos de operação (opcodes) à FPGA</td> </tr> <tr> <td><code>IMAGE_MEM_ptr</code></td> <td>Ponte de memória compartilhada onde a imagem é colocada para que a FPGA leia/processe</td> </tr> <tr> <td><code>fd</code></td> <td>Descriptor do <code>/dev/mem</code> usado para o mapeamento físico</td> </tr> </tbody> </table><h4>Códigos de Operação (Opcode)</h4> <table> <thead> <tr> <th>Constante</th> <th>Valor</th> <th>Descrição</th> </tr> </thead> <tbody> <tr> <td><code>ST_REPLICACAO</code></td> <td><code>0</code></td> <td>Replicação 2x (duplica pixels conforme algoritmo FPGA)</td> </tr> <tr> <td><code>ST_DECIMACAO</code></td> <td><code>1</code></td> <td>Decimação 2x (downsampling / redução)</td> </tr> <tr> <td><code>ST_ZOOMNN</code></td> <td><code>2</code></td> <td>Zoom por vizinho mais próximo (NN) 2x</td> </tr> <tr> <td><code>ST_MEDIA</code></td> <td><code>3</code></td> <td>Filtro de média (suavização) 2x</td> </tr> <tr> <td><code>ST_COPIA_DIRETA</code></td> <td><code>4</code></td> <td>Cópia direta da imagem (transferência sem processamento)</td> </tr> <tr> <td><code>ST_RESET</code></td> <td><code>7</code></td> <td>Reinicializa o estado interno do coprocessador FPGA</td> </tr> <tr> <td><code>ST_REPLICACAO4</code></td> <td><code>8</code></td> <td>Replicação 4x</td> </tr> <tr> <td><code>ST_DECIMACAO4</code></td> <td><code>9</code></td> <td>Decimação 4x</td> </tr> <tr> <td><code>ST_ZOOMNN4</code></td> <td><code>10</code></td> <td>Zoom NN 4x</td> </tr> <tr> <td><code>ST_MED4</code></td> <td><code>11</code></td> <td>Média 4x</td> </tr> </tbody> </table><h3>Principais Funções da API</h3> <ul> <li><code>carregarImagemMIF</code>: Abre arquivo .mif, converte dados hexadecimais em bytes</li> <li><code>mapearPonte</code>: Abre <code>/dev/mem</code>, faz <code>mmap()</code> da região da LW Bridge</li> <li><code>transferirImagemFPGA</code>: Copia bytes do buffer HPS para região mapeada da FPGA</li> <li><code>enviarComando</code>: Escreve opcode no <code>CONTROL_PIO</code> para solicitar operação</li> <li><code>limparRecursos</code>: Libera buffer, faz munmap e fecha descriptor</li> </ul><h3>Resultados da Etapa 2</h3> <p>Durante os testes, verificou-se que as rotinas de escrita e leitura dos registradores mapeados em memória responderam de maneira previsível e confiável. O sistema de carregamento de imagem em formato .mif funcionou conforme esperado, possibilitando a leitura completa do arquivo e o envio dos dados para a FPGA.</p><p>O comportamento do sistema demonstrou baixo tempo de resposta e alta previsibilidade, características fundamentais para aplicações de processamento em tempo real. A execução direta em Assembly contribuiu para uma comunicação de baixo nível mais precisa, eliminando camadas intermediárias.</p> </section><section id="etapa-3"> <h2>Etapa 3: Sistema de Zoom Dinâmico com Interação via Mouse</h2><h3>Arquitetura do Sistema</h3> <p>O projeto desenvolvido nesta terceira etapa consiste em um <strong>sistema de zoom dinâmico</strong> com interação via <strong>mouse USB</strong>. O sistema combina um <strong>processador ARM (HPS)</strong> executando código em C e um <strong>coprocessador gráfico implementado em Verilog na FPGA</strong>, comunicando-se por meio da ponte AXI Lightweight.</p><p>A principal inovação está na introdução da <strong>interação direta por mouse</strong> e na <strong>geração do cursor e área de seleção via overlay em hardware</strong>, o que elimina a necessidade de reescrever a imagem na RAM a cada atualização.</p><h3>Fluxo Geral de Execução</h3> <ol> <li><strong>Inicialização do Sistema</strong>: Carrega imagem .MIF e transfere para framebuffer da FPGA</li> <li><strong>Mapeamento dos PIOs</strong>: Estabelece acesso direto aos registradores da FPGA para controle do cursor e seleção</li> <li><strong>Detecção e Leitura do Mouse</strong>: Thread dedicada lê eventos do mouse via <code>/dev/input/eventX</code></li> <li><strong>Atualização do Overlay em Hardware</strong>: Módulo <code>vga_cursor_overlay.v</code> desenha cursor e seleção sobre o vídeo VGA</li> <li><strong>Execução dos Algoritmos de Zoom</strong>: Funções em C enviam códigos ISA para ativar módulos de processamento</li> <li><strong>Corte e Atualização da Imagem</strong>: Copia área selecionada para centro da imagem, preenchendo demais regiões com preto</li> <li><strong>Loop Contínuo e Multithreading</strong>: Duas threads principais garantem responsividade do sistema</li> </ol><h3>Integração do Mouse USB</h3> <p>A captura dos eventos do mouse é feita por meio da biblioteca <code>linux/input.h</code>. O mouse aparece como um Event Device em <code>/dev/input/eventX</code>, e a biblioteca define a estrutura <code>struct input_event</code> com campos:</p> <ul> <li><code>type</code>: Tipo de ação (ex: <code>EV_REL</code> para movimentos, <code>EV_KEY</code> para cliques)</li> <li><code>code</code>: Identificação do eixo ou botão (ex: <code>REL_X</code>, <code>REL_Y</code>, <code>BTN_LEFT</code>)</li> <li><code>value</code>: Valor associado ao evento (deslocamento em pixels ou estado do botão)</li> </ul><p>O programa em C abre o dispositivo como arquivo e lê eventos em loop contínuo usando <code>read()</code>. O movimento do mouse é sempre relativo (delta X e delta Y), e a aplicação acumula esses valores para posição absoluta do cursor.</p><h3>Overlay de Hardware e Exibição do Cursor</h3> <p>A exibição do cursor e do retângulo de seleção é feita por sobreposição gerada em hardware pelo módulo <code>vga_cursor_overlay.v</code>. Este módulo opera em tempo real dentro do VGA (25 MHz), recebendo coordenadas de varredura da tela (<code>vga_x</code> e <code>vga_y</code>) e comparando com posições do cursor e seleção enviadas via PIOs.</p><p>Quando a coordenada atual coincide com o cursor ou borda da seleção, o módulo substitui o pixel da imagem (<code>pixel_in</code>) por uma cor própria do overlay (<code>CURSOR_COLOR</code> ou <code>SEL_COLOR</code>).</p><h3>Quadro de Seleção e Comando de Zoom</h3> <p>O quadro de seleção é criado pelo usuário via clique e arrasto. Os limites do retângulo são enviados aos PIOs <code>SEL_X1_PIO</code>, <code>SEL_Y1_PIO</code>, <code>SEL_X2_PIO</code> e <code>SEL_Y2_PIO</code>. O módulo de overlay desenha borda fina em branco.</p><p>Após seleção, clique final aciona comando de zoom convertido em Opcode (<code>ZOOM_IN</code> ou <code>DOWNSCALE</code>), escrito no <code>CONTROL_PIO</code>.</p><h3>PIOs Utilizados no Controle do Mouse e Seleção</h3> <table> <thead> <tr> <th>Registrador PIO</th> <th>Função</th> </tr> </thead> <tbody> <tr> <td><code>CURSOR_X_PIO</code> e <code>CURSOR_Y_PIO</code></td> <td>Coordenadas do centro do cursor</td> </tr> <tr> <td><code>CURSOR_ENABLE_PIO</code></td> <td>Flag para ativar/desativar exibição do cursor</td> </tr> <tr> <td><code>SEL_X1_PIO</code> e <code>SEL_Y1_PIO</code></td> <td>Coordenadas do canto superior esquerdo da seleção</td> </tr> <tr> <td><code>SEL_X2_PIO</code> e <code>SEL_Y2_PIO</code></td> <td>Coordenadas do canto inferior direito da seleção</td> </tr> </tbody> </table><h3>Multithreading e Atualizações em C</h3> <p>A <code>main.c</code> foi completamente reestruturada na etapa 3:</p><h4>Principais Mudanças:</h4> <ol> <li><strong>Remoção do Menu Textual</strong>: Substituído por interação direta via mouse</li> <li><strong>Novas Funções de Mapeamento</strong>: Controle de 8 registradores PIO distintos para cursor e seleção</li> <li><strong>Introdução de Multithreading</strong>: Duas threads principais: <ul> <li><code>threadLeituraMouseUSB()</code>: Captura eventos brutos do mouse</li> <li><code>threadAtualizacaoDisplay()</code>: Atualiza PIOs e overlay continuamente</li> </ul> </li> <li><strong>Zoom com Scroll do Mouse</strong>: Controle via scroll com funções <code>aplicarZoomIn()</code>, <code>aplicarZoomOut()</code></li> <li><strong>Função de Corte Intuitiva</strong>: Clique e arrasto para seleção, com <code>aplicarCorte()</code> para processamento</li> </ol><h3>Resultados da Etapa 3</h3> <p>Os testes confirmaram que a integração HPS-FPGA se manteve estável com execução paralela de threads e uso intensivo de eventos do mouse. O overlay de hardware eliminou problemas de cintilação, e a atualização do cursor passou a ser instantânea.</p><p>O corte centralizado com pintura preta mostrou-se funcional e robusto. A troca entre algoritmos é feita sem reinicialização do sistema. Durante testes, o sistema atingiu taxas de atualização compatíveis com clock de 25 MHz do VGA, mantendo estabilidade visual em múltiplas operações consecutivas.</p> </section><section id="conclusoes"> <h2>Conclusões Gerais</h2><p>O projeto evoluiu de um coprocessador gráfico básico em Verilog para um sistema completo de processamento de imagens interativo. Cada etapa trouxe novas capacidades:</p><ol> <li><strong>Etapa 1</strong>: Estabeleceu base hardware com algoritmos eficientes de redimensionamento</li> <li><strong>Etapa 2</strong>: Introduziu comunicação programável HPS-FPGA via API Assembly</li> <li><strong>Etapa 3</strong>: Criou sistema interativo completo com overlay de hardware e controle via mouse</li> </ol><p>O sistema final atende a todos os requisitos originais, oferecendo:</p> <ul> <li>Quatro algoritmos de redimensionamento (replicação, vizinho mais próximo, decimação, média de blocos)</li> <li>Suporte a fatores 2× e 4×</li> <li>Interface interativa intuitiva via mouse USB</li> <li>Exibição em tempo real via VGA</li> <li>Arquitetura modular que facilita extensões futuras</li> </ul><p>A integração bem-sucedida entre HPS e FPGA demonstra a viabilidade de sistemas heterogêneos para aplicações de processamento de imagem em tempo real, combinando flexibilidade de software com desempenho de hardware dedicado.</p> </section><section id="referencias"> <h2>Referências</h2><ol> <li>TERASIC. <em>DE1-SoC Development and Education Board</em>. Disponível em: https://www.rocketboards.org/foswiki/Documentation/TerasicDE1SoCDevelopmentAndEducationBoard</li> <li>INTEL. <em>Intel Quartus Prime Lite Edition - User Guide</em>. Intel FPGA, 2023.</li> <li>CHU, Pong P. <em>FPGA Prototyping by Verilog Examples</em>. 2. ed. Wiley, 2017.</li> <li>HARRIS, David; HARRIS, Sarah. <em>Digital Design and Computer Architecture</em>. 2. ed. Morgan Kaufmann, 2012.</li> <li>ALTERA. <em>DE1-SoC Computer System with ARM Cortex-A9 and FPGA Fabric – Technical Reference Manual</em>. Intel Corporation, 2019.</li> <li>INTEL. <em>Embedded Peripherals IP User Guide</em>. Intel FPGA Documentation, 2021.</li> <li>ARM Limited. <em>ARM Architecture Reference Manual: ARMv7-A and ARMv7-R edition</em>. ARM, 2012.</li> <li>INTEL FPGA University Program. <em>DE1-SoC Computer and Qsys System Design Tutorial</em>. Intel Education, 2020.</li> <li>Linux Kernel Documentation. <em>Input Subsystem and Event Devices</em> — <code>linux/input.h</code>.</li> <li>Material didático da disciplina de Sistemas Digitais e Arquitetura de Computadores – UEFS, 2025.</li> </ol> </section>
