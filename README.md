<section id="descricao-geral"> <h2>Descrição Geral do Projeto</h2><div align="center"> <img src="https://www.rocketboards.org/foswiki/pub/Documentation/TerasicDE1SoCDevelopmentAndEducationBoard/igp_3e6715c483b2d44cc78aca35b032c4ef_DE1-SoC_top_s.jpg"><br> <strong>Placa DE1-SoC utilizada no projeto</strong><br><br> </div><p>Este projeto consiste no desenvolvimento de um sistema completo de processamento de imagens em tempo real, implementado na placa DE1-SoC da Terasic. O sistema evoluiu através de três etapas principais, integrando progressivamente hardware programável (FPGA) com software de controle (HPS - Hard Processor System) para criar uma solução robusta de redimensionamento de imagens com interface interativa.</p><p>A primeira etapa focou na implementação de um coprocessador gráfico em Verilog capaz de realizar operações de zoom-in e zoom-out através de algoritmos especializados. A segunda etapa introduziu uma API em Assembly ARM para comunicação programável entre o HPS e a FPGA, substituindo o controle manual por chaves físicas. A terceira e última etapa implementou um sistema interativo completo com controle via mouse USB, overlay de hardware para cursor e seleção, e operações dinâmicas de corte e zoom.</p><p>O sistema final permite que usuários selecionem regiões específicas de uma imagem, apliquem algoritmos de redimensionamento em tempo real, e visualizem os resultados instantaneamente através da saída VGA, tudo controlado de forma intuitiva através de movimentos e cliques do mouse.</p> </section><section id="etapa-1"> <h2>Etapa 1: Coprocessador Gráfico em Verilog</h2><h3>Arquitetura e Componentes</h3> <p>O sistema segue o princípio de <strong>separação de funções</strong>, com uma hierarquia de controle clara e um <em>datapath</em> dedicado para operações de imagem. O módulo de topo <code>control_unity</code> integra todos os componentes, enquanto a <code>ULA</code> atua como uma unidade de controle especializada, gerenciando o fluxo de dados entre as memórias e os aceleradores de hardware.</p><div align="center"> <img src="diagramas/arquiteturgeral.png"><br> <strong>Diagrama da Arquitetura Geral do Sistema</strong><br><br> </div><h4>Componentes Principais:</h4> <ul> <li><strong>ULA</strong>: FSM hierárquica que gerencia o fluxo do sistema baseado nas entradas do usuário</li> <li><strong>Framebuffer (RAM Dual-Port)</strong>: Permite processamento e exibição de vídeo independentes</li> <li><strong>Memória ROM</strong>: Armazena a imagem original de 160x120 pixels em escala de cinza</li> <li><strong>Memória RAM</strong>: Armazena as imagens alteradas, sendo sobreescrita conforme o algoritmo selecionado</li> <li><strong>Módulos dos Algoritmos</strong>: Circuitos dedicados para cada técnica de processamento</li> </ul><h3>DataPath e Fluxo de Execução</h3> <p>O fluxo de execução segue uma sequência bem definida:</p> <ol> <li>No estado <code>ST_RESET</code>, a Unidade de Controle lê a seleção do usuário e configura o Datapath</li> <li>A FSM transita pelos estados operacionais, lendo pixels da ROM, enviando-os ao acelerador de hardware e escrevendo os resultados no Framebuffer</li> <li>O driver VGA lê continuamente o Framebuffer pela porta de leitura, exibindo pixels a 25 MHz</li> </ol><h3>Algoritmos de Redimensionamento</h3> <p>O sistema implementa quatro algoritmos principais para redimensionamento:</p><h4>Replicação de Pixel (Zoom-In)</h4> <p>Cada pixel é replicado fator×fator vezes, aumentando as dimensões da imagem sem interpolação.</p> <div align="center"> <img src="diagramas/replicacao_pixels_animada.gif"><br> <strong>Funcionamento de Replicação de Pixel - Fator 2 em uma matriz 2×2</strong><br><br> </div> <p>No módulo <code>rep_pixel</code>, o cálculo do endereço é feito como:</p> <pre><code>ram_wraddr = (linha * fator + di) * NEW_LARG + (coluna * fator + dj)</code></pre><h4>Vizinho Mais Próximo (Zoom-In)</h4> <p>Cada novo pixel da imagem ampliada recebe o valor do pixel mais próximo da imagem original.</p> <div align="center"> <img src="diagramas/vizinho_mais_proximo_matriz_compacto.gif"><br> <strong>Funcionamento de Vizinho Mais Próximo - Fator 2 em uma matriz 2×2</strong><br><br> </div> <p>Implementado no módulo <code>zoom_nn</code>, utiliza a mesma lógica de endereçamento da replicação.</p><h4>Decimação (Zoom-Out)</h4> <p>Reduz a imagem descartando pixels de forma sistemática, mantendo apenas pixels espaçados pelo fator especificado.</p> <div align="center"> <img src="diagramas/decimacao_animada.gif"><br> <strong>Funcionamento de Decimação - Fator 2 em uma matriz 4×4</strong><br><br> </div> <p>O cálculo do endereço é:</p> <pre><code>addr_ram_vga = (y_in / fator) * NEW_LARG + (x_in / fator)</code></pre><h4>Média de Blocos (Zoom-Out)</h4> <p>Divide a imagem em blocos fator×fator e calcula a média dos valores, substituindo cada bloco por um único pixel.</p> <div align="center"> <img src="diagramas/media_blocos.gif"><br> <strong>Funcionamento de Média de Blocos - Fator 2 em uma matriz 4×4</strong><br><br> </div> <p>Utiliza o mesmo cálculo de endereço da decimação, mas com processamento adicional de média.</p><h3>Módulo VGA e Exibição</h3> <p>O <code>vga_driver</code> é responsável por exibir o framebuffer no padrão VGA analógico, gerando quadros de 640×480 pixels a 60 Hz usando clock de 25 MHz. Implementa temporização precisa com contadores horizontais (0-799) e verticais (0-524), incluindo sincronismo HSYNC e VSYNC.</p><p>Para exibir a imagem processada (normalmente 160×120) na tela de 640×480, o driver realiza escala 4×, centralização automática e leitura contínua do framebuffer via porta dual-port da RAM.</p><h3>Resultados da Etapa 1</h3> <p>O projeto alcançou com êxito todos os pré-requisitos do problema, permitindo zoom-in e zoom-out com quatro algoritmos diferentes em fatores 2× e 4×. A arquitetura seguiu o modelo desejado, facilitando futuras integrações com demais componentes.</p><div align="center"> <img src="diagramas/produto.gif"><br> <strong>Sessão de testes aplicando todos os 4 algoritmos em ambos os fatores</strong><br><br> </div><p>Como erro principal, foi observada uma linha lateral em algumas imagens, principalmente na imagem original (160×120). A suspeita é que exista um erro no cálculo dos parâmetros next_x e next_y.</p> 
